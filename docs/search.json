[
  {
    "objectID": "technical.html",
    "href": "technical.html",
    "title": "Technical Information",
    "section": "",
    "text": "This system produces two independent audio outputs, one driven by the gyroscope-derived baseline frequency and one driven by keypad+knob inputs. The MCU ingests user inputs, maps them to frequencies, and generates digital waveforms which the FPGA filters and processes. The final waveforms are converted to analog and amplified to the speakers.\n\n\n\n\n\n\n\nGyroscope to MCU: SPI, 8-bit samples (per project description)\nKeypad to MCU: GPIO matrix scanning\nKnobs to MCU: On-chip ADC channels (voltage from potentiometers)\nMCU to FPGA: SPI (waveform samples, control/status)\nFPGA to DACs: I2C (two channels for two speakers)"
  },
  {
    "objectID": "technical.html#system-architecture",
    "href": "technical.html#system-architecture",
    "title": "Technical Information",
    "section": "",
    "text": "This system produces two independent audio outputs, one driven by the gyroscope-derived baseline frequency and one driven by keypad+knob inputs. The MCU ingests user inputs, maps them to frequencies, and generates digital waveforms which the FPGA filters and processes. The final waveforms are converted to analog and amplified to the speakers.\n\n\n\n\n\n\n\nGyroscope to MCU: SPI, 8-bit samples (per project description)\nKeypad to MCU: GPIO matrix scanning\nKnobs to MCU: On-chip ADC channels (voltage from potentiometers)\nMCU to FPGA: SPI (waveform samples, control/status)\nFPGA to DACs: I2C (two channels for two speakers)"
  },
  {
    "objectID": "technical.html#calculations-and-performance",
    "href": "technical.html#calculations-and-performance",
    "title": "Technical Information",
    "section": "Calculations and Performance",
    "text": "Calculations and Performance\n\nFrequency resolution: ( = )\nPCLK minimum speed (given): ( _{} = )\nLow-pass filter example: ( N = 4 )\nHigh-pass filter example: ( N = 8 )\nMultiplier estimate: Each one requires ( (N/2)_2 N ) multipliers\n\n( 2_2(4) + 4_2(8) = 4 + 12 = 16 ) complex 8-bit multipliers\n\n\nNotes: - Select sampling rate and FFT/window sizes to meet target frequency resolution and latency. - Ensure SPI bandwidth supports aggregate waveform/control traffic between MCU and FPGA. - I2C bus timing must accommodate two DAC channels at chosen audio sample rate."
  },
  {
    "objectID": "technical.html#risk-elements",
    "href": "technical.html#risk-elements",
    "title": "Technical Information",
    "section": "Risk Elements",
    "text": "Risk Elements\n\nSlip ring + gyroscope signal integrity and noise are the top risk. The signal must remain readable at the target spin frequency; additional filtering and shielding may be necessary.\nScheduling and concurrency: The MCU must read keypad/gyro and stream/control audio at rates that keep both outputs continuous and within range, while allowing the FPGA adequate time for filtering.\nTuning filter parameters and stability: Filter orders and cutoff frequencies must be tuned to avoid audible artifacts and preserve musical intent."
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Results",
    "section": "",
    "text": "Audio outputs: Two independent channels produced in real time\nFrequency mapping: Gyro-derived baseline and keypad-derived note frequencies"
  },
  {
    "objectID": "results.html#key-results",
    "href": "results.html#key-results",
    "title": "Results",
    "section": "",
    "text": "Audio outputs: Two independent channels produced in real time\nFrequency mapping: Gyro-derived baseline and keypad-derived note frequencies"
  },
  {
    "objectID": "results.html#measurements",
    "href": "results.html#measurements",
    "title": "Results",
    "section": "Measurements",
    "text": "Measurements"
  },
  {
    "objectID": "results.html#discussion",
    "href": "results.html#discussion",
    "title": "Results",
    "section": "Discussion",
    "text": "Discussion"
  },
  {
    "objectID": "media.html",
    "href": "media.html",
    "title": "Media",
    "section": "",
    "text": "Embed or link a short video showcasing the system in action."
  },
  {
    "objectID": "media.html#demo-video",
    "href": "media.html#demo-video",
    "title": "Media",
    "section": "",
    "text": "Embed or link a short video showcasing the system in action."
  },
  {
    "objectID": "media.html#photos",
    "href": "media.html#photos",
    "title": "Media",
    "section": "Photos",
    "text": "Photos\n\nFinal design photos (front, back, internals)\nBuild process photos\n\nAdd images to an images/ folder and reference them here, for example:"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home Page",
    "section": "",
    "text": "The goal of this project is to design an analog style synthesizer with an instrument that makes sound when you spin it, press keys or turn knobs. The project generates real time audio controlled by a digital gyroscope, keypad, and knobs. The system produces two independent audio outputs, each corresponding to a distinct sound source. - The gyroscope is mounted on a spinning device and the rotational frequency determines a baseline sound output to one speaker. - The keypad and knobs control the note and pitch of another sound output to a different speaker."
  },
  {
    "objectID": "index.html#project-description-and-overview",
    "href": "index.html#project-description-and-overview",
    "title": "Project Overview",
    "section": "",
    "text": "The goal of this project is to design an analog style synthesizer with an instrument that makes sound when you spin it, press keys or turn knobs. The project generates real time audio controlled by a digital gyroscope, keypad, and knobs. The system produces two independent audio outputs, each corresponding to a distinct sound source.\n\nThe gyroscope is mounted on a spinning device and the rotational frequency determines a baseline sound output to one speaker.\nThe keypad and knobs control the note and pitch of another sound output to a different speaker.\n\nThe system uses two core processing units: a microcontroller (MCU) and an FPGA.\n\nThe MCU handles all user input from the gyroscope and keypad using the I2C protocol. It performs frequency mapping, converting the measured angular velocity or note input into precise frequency values, and generates a corresponding digital waveform. These waveforms are transmitted to the FPGA over the Serial Peripheral Interface (SPI).\nOn the FPGA, waveforms from the MCU are sent to an external DAC and then amplifyed to speakers."
  },
  {
    "objectID": "index.html#quick-links",
    "href": "index.html#quick-links",
    "title": "Project Overview",
    "section": "Quick Links",
    "text": "Quick Links\n\nTechnical Information\nMCU Design\nFPGA Design\nBill of Materials\nResults\nReferences\nTeam\nAcknowledgements"
  },
  {
    "objectID": "bom.html",
    "href": "bom.html",
    "title": "Bill of Materials",
    "section": "",
    "text": "// Include image of BOM"
  },
  {
    "objectID": "acknowledgements.html",
    "href": "acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "We thank Prof. Spencer and peers for feedback on design decisions. Also, thank you to the grutors for this class: Kavi, Troy, Vikram, and Neil for their support."
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "FPGA Design",
    "section": "",
    "text": "This project uses the iCE40 UP5K FPGA on the UPdino v3.1 development board. Originally, the FPGA was intended to act as a hardware accelerator for audio equalization. Specifically, the FPGA would apply a low-pass FIR filter to a square wave generated by the MCU. The MCU would send two square waves to the FPGA–one of the frequency corresponding to the pressed key, and one of the frequency corresponding to the gyroscope’s angular speed– connected by wire.\nIn addition, the MCU would send the desired cutoff frequency of the low-pass filter, encoded with 4 bits, and also transmitted over wires. However, SPI also could have been used to transmit the cutoff frequency in order to increase resolution. The 4-bit cutoff frequency value would correspond to frequency spanning from 200 to 1600 Hz. This range was designed with the intended keypad range of middle C (~261 Hz) to C5 (~523 Hz), so 200-1600Hz should be an effective range of cutoff frequencies for the low-pass filter.\nInternally, a divided clock based on the HSOSC IP module would be used to generate a 44kHz signal to sample the audio inputs. This frequency was selected because 44kHz is double the highest audible audio frequency, making it a standard audio sampling frequency. The audio data would be sampled into a 51-bit wide shift register. Simultaneously, 51 16-bit taps corresponding to the cutoff frequency would be read in from BRAM. These taps would be convolved with the shift register of past inputs in order to calculate the current audio output. This would be accomplished using the sysDSP SB_MAC16 primitive on the iCE40.\n\n\n\nBasic FIR filter design, Whitney Knitter via. Hackster.io\n\n\nSince the input is a square wave, the multiplication of each previous input with the corresponding tap should be relatively straightforward. The main source of complexity would be in the accumulation of all 51 taps. Executing all of this combinational logic would be challenge to fit within one clock cycle, giving rise to timing issues. As a result, this process would have to be pipelined, running over multiple clock cycles. Assuming the FPGA clock (based on HSOSC) is running at 40MHz and the FPGA is sampling the input at 44kHz, 900 processing cycles could fit within the time between samples. 900 cycles is more than enough to accumulate 51 16-bit precision taps. Thus, timing is not a concern with pipelining the FIR filter.\nIn order to hold the FIR filter output steady while the FIR filter is generating the next output, a synchronous enabled flop would be used to control the input to and output from the FIR filter module. This flop would be enabled based on an input ready signal, based on the 44kHz sampling signal, and output ready signal, driven by the controller of the FIR filter datapath.\nThere would be two instances of the FIR filter module, one for the MCU output driven by the keypad, and the other for the MCU output driven by the gyroscope. The outputs of the FIR filters then would be converted to 8-bit audio values, which would then be transmitted over The DACs would then be used to drive two speakers. I2C would be implemented using the built-in I2C IP on the iCE40. The MCP4725 DAC supports a standard 100 kHz communication frequency, as well as a 400 kHz fast mode and a 3.4 MHz high-speed mode. Additionally, the DAC must be sent 4 bytes (or 32 bits) in every transaction writing to the DAC Input Register. This means that the DAC fast mode speed of 400 kHz would be more than sufficient to drive audio at 44kHz."
  },
  {
    "objectID": "fpga.html#fpga-overview-ice40-up5k-on-upduino-v3.1",
    "href": "fpga.html#fpga-overview-ice40-up5k-on-upduino-v3.1",
    "title": "FPGA Design",
    "section": "",
    "text": "The FPGA receives square waves from the MCU over wires. It sends those waves to external DACs over I2C (two channels for two independent speakers).\n\n\n\nI/O:\n\nSPI interface for waveform/control with MCU\nI2C master to two external DACs\n\n\n\n\n\n\nReceive digital waveform samples from MCU over SPI\nOutput two-channel digital audio via I2C to external DACs\nDAC analog outputs are amplified and sent to speakers"
  },
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "MCU Design",
    "section": "",
    "text": "The MCU reads three inputs to determine the two output frequencies:\n\nKeypad (8 keys) via GPIO scanning\nGyroscope via SPI (8-bit angular acceleration/velocity data)\nKnobs via on-chip ADC (continuous control for pitch/modulation)\n\nBased on these inputs, the MCU computes two desired frequencies to be played on two speakers. The MCU generates corresponding digital waveforms and communicates with the FPGA over SPI for filtering and additional DSP.\n\n\n\nInput acquisition: GPIO keypad scan, SPI gyro reads, ADC sampling (knobs)\nFrequency mapping: Key-to-frequency and angular velocity-to-frequency conversions\nWaveform generation: Digital oscillators at target frequencies\nStreaming/control to FPGA via SPI\nReceiving filtered waveforms/status from FPGA\n\n\n\n\nA pin on the MCU is connected to a timer associated with one of the two target frequencies. The timer is toggled at a rate fast enough that the resulting composite output sounds like the sum of the two notes, while remaining slow enough for the FPGA to sample and filter both components effectively. This balances perceptual audio quality with FPGA processing constraints.\n\n\n\n\nSPI: Gyroscope reads, waveform/control data exchange with FPGA\nGPIO: 8-key keypad matrix\nADC: Knob voltages (modulation, pitch bend, filter control, etc.)"
  },
  {
    "objectID": "mcu.html#mcu-overview-stm32l432kc",
    "href": "mcu.html#mcu-overview-stm32l432kc",
    "title": "MCU Design",
    "section": "",
    "text": "The MCU reads three inputs to determine the two output frequencies:\n\nKeypad (8 keys) via GPIO scanning\nGyroscope via SPI (8-bit angular acceleration/velocity data)\nKnobs via on-chip ADC (continuous control for pitch/modulation)\n\nBased on these inputs, the MCU computes two desired frequencies to be played on two speakers. The MCU generates corresponding digital waveforms and communicates with the FPGA over SPI for filtering and additional DSP.\n\n\n\nInput acquisition: GPIO keypad scan, SPI gyro reads, ADC sampling (knobs)\nFrequency mapping: Key-to-frequency and angular velocity-to-frequency conversions\nWaveform generation: Digital oscillators at target frequencies\nStreaming/control to FPGA via SPI\nReceiving filtered waveforms/status from FPGA\n\n\n\n\nA pin on the MCU is connected to a timer associated with one of the two target frequencies. The timer is toggled at a rate fast enough that the resulting composite output sounds like the sum of the two notes, while remaining slow enough for the FPGA to sample and filter both components effectively. This balances perceptual audio quality with FPGA processing constraints.\n\n\n\n\nSPI: Gyroscope reads, waveform/control data exchange with FPGA\nGPIO: 8-key keypad matrix\nADC: Knob voltages (modulation, pitch bend, filter control, etc.)"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Below are citations to datasheets and tools relevant to this project. Add any additional references used during design and implementation."
  },
  {
    "objectID": "references.html#cited-works",
    "href": "references.html#cited-works",
    "title": "References",
    "section": "Cited Works",
    "text": "Cited Works\nThis page uses the site bibliography (references.bib). Example citations:\n\nSTM32L432 MCU datasheet (STM32L432KC Datasheet 2018)\nLattice iCE40 UltraPlus FPGA (iCE40 UltraPlus Family Data Sheet 2017)\nQuarto documentation (Quarto Documentation 2025)"
  },
  {
    "objectID": "references.html#links",
    "href": "references.html#links",
    "title": "References",
    "section": "Links",
    "text": "Links\n\nSTM32 Nucleo-32 (NUCLEO-L432KC) — see vendor page\nUPduino v3.1 board resources — see vendor page\nKiCad EDA tool — see project page"
  },
  {
    "objectID": "team.html",
    "href": "team.html",
    "title": "Meet the Team!",
    "section": "",
    "text": "Madeleine Kan is a senior engineering major at Harvey Mudd College. She is studying general engineering with a focus on computer engineering with biomedical applications. She has experience in supply chain process engineering, firmware engineering, and RTL design and verificaiton. In the spring of 2025, she worked as part of the UC Berkeley clinic team to upgrade the communication protocol for a low-cost air quality sensor. Since the start of 2024, she has worked in the Quantum Quasars Lab to develop an astronomical random number generator for Bell-type tests of quantum entanglement. She also has tutored for a variety of engineering courses and labs. She is part of the CMS Swim team, specializing in sprint freestyle and butterfly. In her free time, she likes to crochet, learn the piano, and spend time with her friends and family.\nLinks\nPersonal E155 Portfolio  GitHub\n LinkedIn\n\nSarah is a current undergraduate student in Computer Science, Mathematics, and Economics, she is passionate about leveraging technology and analytical problem-solving to drive impactful solutions. Her experience spans software development, optimization, and data analysis, with projects ranging from building AI-powered applications to designing mathematical models for decision-making.\nShe is always eager to explore innovative applications of technology, connect with like-minded professionals, and contribute to projects that create meaningful impact.\nLinks\n GitHub\n LinkedIn"
  },
  {
    "objectID": "team.html#team-members",
    "href": "team.html#team-members",
    "title": "Team",
    "section": "",
    "text": "Provide names, short bios, and links to personal websites or LinkedIn profiles.\n\nName — Short bio. Website/LinkedIn\nName — Short bio. Website/LinkedIn\nName — Short bio. Website/LinkedIn"
  },
  {
    "objectID": "madeleine.html",
    "href": "madeleine.html",
    "title": "Spinning Synth: MCU + FPGA Audio System",
    "section": "",
    "text": "Madeleine Kan is a senior engineering major at Harvey Mudd College. She is studying general engineering with a focus on computer engineering with biomedical applications. She has experience in supply chain process engineering, firmware engineering, and RTL design and verificaiton. In the spring of 2025, she worked as part of the UC Berkeley clinic team to upgrade the communication protocol for a low-cost air quality sensor. Since the start of 2024, she has worked in the Quantum Quasars Lab to develop an astronomical random number generator for Bell-type tests of quantum entanglement. She also has tutored for a variety of engineering courses and labs. She is part of the CMS Swim team, specializing in sprint freestyle and butterfly. In her free time, she likes to crochet, learn the piano, and spend time with her friends and family.\nLinks\nPersonal E155 Portfolio\n GitHub\n LinkedIn"
  },
  {
    "objectID": "sarah.html",
    "href": "sarah.html",
    "title": "Spinning Synth: MCU + FPGA Audio System",
    "section": "",
    "text": "Sarah is a current undergraduate student in Computer Science, Mathematics, and Economics, she is passionate about leveraging technology and analytical problem-solving to drive impactful solutions. Her experience spans software development, optimization, and data analysis, with projects ranging from building AI-powered applications to designing mathematical models for decision-making.\nShe is always eager to explore innovative applications of technology, connect with like-minded professionals, and contribute to projects that create meaningful impact.\nLinks\n GitHub\n LinkedIn"
  },
  {
    "objectID": "index.html#github-repository",
    "href": "index.html#github-repository",
    "title": "Project Overview",
    "section": "GitHub Repository",
    "text": "GitHub Repository\nGitHub Repository"
  },
  {
    "objectID": "index.html#video",
    "href": "index.html#video",
    "title": "Home Page",
    "section": "Video",
    "text": "Video"
  },
  {
    "objectID": "index.html#link-to-github",
    "href": "index.html#link-to-github",
    "title": "Home Page",
    "section": "Link to GitHub",
    "text": "Link to GitHub\nGitHub"
  },
  {
    "objectID": "system-overview.html#block-diagram",
    "href": "system-overview.html#block-diagram",
    "title": "System Overview",
    "section": "Block Diagram",
    "text": "Block Diagram"
  },
  {
    "objectID": "system-overview.html#what-is-new-compared-to-previous-learning",
    "href": "system-overview.html#what-is-new-compared-to-previous-learning",
    "title": "System Overview",
    "section": "What is New (Compared to Previous Learning)",
    "text": "What is New (Compared to Previous Learning)"
  },
  {
    "objectID": "hardware.html#circuit-diagram",
    "href": "hardware.html#circuit-diagram",
    "title": "Hardware",
    "section": "Circuit Diagram",
    "text": "Circuit Diagram"
  },
  {
    "objectID": "hardware.html#bom",
    "href": "hardware.html#bom",
    "title": "Hardware",
    "section": "BOM",
    "text": "BOM"
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "Home Page",
    "section": "",
    "text": "The goal of this project is to design an analog style synthesizer with an instrument that makes sound when you spin it, press keys or turn knobs. The project generates real time audio controlled by a digital gyroscope, keypad, and knobs. The system produces two independent audio outputs, each corresponding to a distinct sound source. - The gyroscope is mounted on a spinning device and the rotational frequency determines a baseline sound output to one speaker. - The keypad and knobs control the note and pitch of another sound output to a different speaker."
  },
  {
    "objectID": "system-overview.html#what-is-new",
    "href": "system-overview.html#what-is-new",
    "title": "System Overview",
    "section": "What is New",
    "text": "What is New"
  },
  {
    "objectID": "fpga.html#fpga-design-overview",
    "href": "fpga.html#fpga-design-overview",
    "title": "FPGA Design",
    "section": "",
    "text": "Originally, the FPGA was intended to act as a hardware accelerator for audio equilization. Specifically, the FPGA would apply a low-pass FIR filter to a square wave generated by the MCU. The MCU would send two square waves to the FPGA–one of the frequency corresponding to the pressed key, and one of the frequency corresponding to the gyroscope’s angular speed– connected by wire.\nIn addition, the MCU would send the desired cutoff frequency of the low-pass filter, encoded with 4 bits, and also transmitted over wires. However, SPI also could have been used to transmit the cutoff frequency in order to increase resolution. The 4-bit cutoff frequency value would correspond to frequency spanning from 200 to 1600 Hz. This range was designed with the intended keypad range of middle C (~261 Hz) to C5 (~523 Hz), so 200-1600Hz should be an effective range of cutoff frequencies for the low-pass filter.\nInternally, a divided clock based on the HSOSC IP module would be used to generate a 44kHz signal to sample the audio inputs. The audio data would be sampled into a 51-bit wide shift register. Simultaneously, 51 taps corresponding to the cutoff frequency would be read in from BRAM. These taps would be convolved with the shift register of past inputs in order to calculate the current audio output. This would be accomplished using the sysDSP SB_MAC16 primitive on the iCE40.\n\n\n\nBasic FIR filter design, Whitney Knitter via. Hackster.io\n\n\nSince the input is a square wave, the multiplication of each previous input with the corresponding tap should be relatively straightforward. The main source of complexity would be in the accumulation of all 51 taps. Executing all of this combinational logic would be challenge to fit within one clock cycle, giving rise to timing issues. As a result, this process would have to be pipelined, running over multiple clock cycles. Assuming the FPGA clock (based on HSOSC) is running at 40MHz and the FPGA is sampling the imput at 44kHz, 900 processing cycles could fit within the time between samples. 900 cycles is more than enough to add 51 8-bit precision taps. Thus, timing is not a concern with the pipelining the FIR filter.\n// just adition // links, equations, etc ## Theoretical Block Diagram"
  },
  {
    "objectID": "fpga.html#theoretical-block-diagram",
    "href": "fpga.html#theoretical-block-diagram",
    "title": "FPGA Design",
    "section": "Theoretical Block Diagram",
    "text": "Theoretical Block Diagram"
  },
  {
    "objectID": "fpga.html#filter-design",
    "href": "fpga.html#filter-design",
    "title": "FPGA Design",
    "section": "Filter Design",
    "text": "Filter Design\nThe FIR low-pass filter was designed to have 51 taps using the window method, as implemented by the firwin function in the SciPy Signal Processing library. This number was determined experimentally. Through trials with a varying number of taps, 51 was one of the lowest numbers where the audio filtering was noticeable. The 51 taps were then calculated for 15 cutoff frequencies, spanning from 200 Hz to 1.6 kHz.\n\n\n\nFIR low-pass filter taps vs cutoff frequency\n\n\nAll of these taps were then converted to 16-bit 2s-complement, and loaded into BRAM. An itial idea was to calculate the 51 taps using lines of best fit (selected by cutoff frequency), but the necessary precision would have required floating-point arithmetic, which is not supported on the FPGA."
  },
  {
    "objectID": "fpga.html#references",
    "href": "fpga.html#references",
    "title": "FPGA Design",
    "section": "References",
    "text": "References\nPiano Key Frequencies - Wikipedia\nDSP for FPGA: Simple FIR Filter in Verilog - Whitney Knitter, Hackster.io\nMCP4725 Datasheet\nProject PariVo, E155 2024\nSciPy Signal Processing firwin"
  },
  {
    "objectID": "fpga.html#fpga-design-plan",
    "href": "fpga.html#fpga-design-plan",
    "title": "FPGA Design",
    "section": "",
    "text": "This project uses the iCE40 UP5K FPGA on the UPdino v3.1 development board. Originally, the FPGA was intended to act as a hardware accelerator for audio equalization. Specifically, the FPGA would apply a low-pass FIR filter to a square wave generated by the MCU. The MCU would send two square waves to the FPGA–one of the frequency corresponding to the pressed key, and one of the frequency corresponding to the gyroscope’s angular speed– connected by wire.\nIn addition, the MCU would send the desired cutoff frequency of the low-pass filter, encoded with 4 bits, and also transmitted over wires. However, SPI also could have been used to transmit the cutoff frequency in order to increase resolution. The 4-bit cutoff frequency value would correspond to frequency spanning from 200 to 1600 Hz. This range was designed with the intended keypad range of middle C (~261 Hz) to C5 (~523 Hz), so 200-1600Hz should be an effective range of cutoff frequencies for the low-pass filter.\nInternally, a divided clock based on the HSOSC IP module would be used to generate a 44kHz signal to sample the audio inputs. This frequency was selected because 44kHz is double the highest audible audio frequency, making it a standard audio sampling frequency. The audio data would be sampled into a 51-bit wide shift register. Simultaneously, 51 16-bit taps corresponding to the cutoff frequency would be read in from BRAM. These taps would be convolved with the shift register of past inputs in order to calculate the current audio output. This would be accomplished using the sysDSP SB_MAC16 primitive on the iCE40.\n\n\n\nBasic FIR filter design, Whitney Knitter via. Hackster.io\n\n\nSince the input is a square wave, the multiplication of each previous input with the corresponding tap should be relatively straightforward. The main source of complexity would be in the accumulation of all 51 taps. Executing all of this combinational logic would be challenge to fit within one clock cycle, giving rise to timing issues. As a result, this process would have to be pipelined, running over multiple clock cycles. Assuming the FPGA clock (based on HSOSC) is running at 40MHz and the FPGA is sampling the input at 44kHz, 900 processing cycles could fit within the time between samples. 900 cycles is more than enough to accumulate 51 16-bit precision taps. Thus, timing is not a concern with pipelining the FIR filter.\nIn order to hold the FIR filter output steady while the FIR filter is generating the next output, a synchronous enabled flop would be used to control the input to and output from the FIR filter module. This flop would be enabled based on an input ready signal, based on the 44kHz sampling signal, and output ready signal, driven by the controller of the FIR filter datapath.\nThere would be two instances of the FIR filter module, one for the MCU output driven by the keypad, and the other for the MCU output driven by the gyroscope. The outputs of the FIR filters then would be converted to 8-bit audio values, which would then be transmitted over The DACs would then be used to drive two speakers. I2C would be implemented using the built-in I2C IP on the iCE40. The MCP4725 DAC supports a standard 100 kHz communication frequency, as well as a 400 kHz fast mode and a 3.4 MHz high-speed mode. Additionally, the DAC must be sent 4 bytes (or 32 bits) in every transaction writing to the DAC Input Register. This means that the DAC fast mode speed of 400 kHz would be more than sufficient to drive audio at 44kHz."
  },
  {
    "objectID": "fpga.html#fpga-design-reality",
    "href": "fpga.html#fpga-design-reality",
    "title": "FPGA Design",
    "section": "FPGA Design Reality",
    "text": "FPGA Design Reality\nDue to unforeseen circumstances, the team had to rescope the project to greatly simplify the role of the FPGA in this project. Initially, the FIR filter was removed from the project entirely, leaving the FPGA to serve as a buffer between the MCU’s square wave outputs and the DACs. The data that previously encoded the FIR filter cutoff frequency would instead be used to control output volume. So, the FPGA would read in the two square waves from the MCU at 44kHz, scale them by an amount proportional to the 4-bit volume value, and send this result over I2C to the two DACs to ultimately drive the two speakers with two square waves at the specified volume.\nUnfortunately, the microcontroller and hardware design aspects of the project took longer than expected, and the team did not complete the rescoped FPGA design."
  }
]